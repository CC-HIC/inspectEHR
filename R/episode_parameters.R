#' Report Weekly Admissions
#'
#' Shows the number of admissions to each each in terms of
#' patients and episodes stratified in weeks
#'
#' @param distinct_episodes from reference table
#' @return a summary containing patient and episode numbers
#' @export
#'
#' @examples
#' weekly_admissions(distinct_episodes)
weekly_admissions <- function(distinct_episodes = NULL) {

  admissions <- distinct_episodes %>%
    dplyr::mutate(
      year = lubridate::year(start_date),
      month = lubridate::month(start_date, label = TRUE),
      week_of_month = as.integer(ceiling(lubridate::day(start_date) / 7))
    ) %>%
    dplyr::group_by(site, year, month, week_of_month) %>%
    dplyr::summarise(patients = n_distinct(nhs_number),
                     episodes = n_distinct(episode_id))

  return(admissions)

}


#' Reports Case Numbers according to day
#'
#' @param unique_cases_tbl from \code{pull_cases_all}
#'
#' @return breakdown of unique daily cases
#' @export
#'
#' @examples
#' report_cases_daily(unique_cases)
report_cases_daily <- function(unique_cases_tbl = NULL) {

  cases <- unique_cases_tbl %>%
    mutate(year = lubridate::year(start_date),
           month = lubridate::month(start_date, label = TRUE),
           week_of_month = as.integer(ceiling(lubridate::day(start_date)/7)),
           wday = lubridate::wday(start_date, label = TRUE)) %>%
    group_by(site, year, month, week_of_month, wday) %>%
    summarise(patients = n_distinct(nhs_number),
              episodes = n_distinct(episode_id))

  return(cases)

}


#' Daily Admissions for each Site
#'
#' Calculates the number of admissions for each calendar day, stratified
#' by site. This is a complete table, i.e. days with 0 admissions are not
#' listed
#'
#' @param reference the reference table generated by \code{\link{make_reference}}
#' @param by_site the named site of interest as a character
#'
#' @return a tibble with the number of unique episodes admitted for a given day
#' @export
#'
#' @examples
#' daily_admssions(unique_cases, by_site == "UCL")
daily_admssions <- function(reference = NULL, by_site = NULL) {

  admissions <- reference %>%
    filter(site == by_site) %>%
    mutate(date = lubridate::date(start_date)) %>%
    group_by(date) %>%
    summarise(episodes = n_distinct(episode_id)) %>%
    filter(episodes > 0)

  return(admissions)

}


#' Event Occurrances for each Site
#'
#' Calculates the number of event occurances for each calendar day, stratified
#' by site. Days with 0 event submissions are not listed
#'
#' @param extracted_event extracted HIC event
#' @param by_site a site code as a character vector
#'
#' @return a tibble with the number of unique episodes admitted for a given day
#' @export
#'
#' @examples
#' event_occurrances(x, by_site == "UCL")
event_occurrances <- function(extracted_event = NULL, by_site = "UCL") {

  occurances <- extracted_event %>%
    filter(site == by_site) %>%
    mutate(date = lubridate::date(datetime)) %>%
    group_by(date) %>%
    summarise(events = n_distinct(internal_id)) %>%
    filter(events > 0)

  return(occurances)

}


#' Report Admission Numbers for each Unit
#'
#' Reports on ICNARC CMP unit codes to describe the numbers of reported cases by site.
#' This is dependent on accurate parsing of the xml schema for hic code 0002 (INCARC CMP
#' unit code). And as such, may dramatically under-report. To see a comprehensive list
#' of acual cases, see the \code{weekly_admissions} function.
#'
#' @param events_table the events table
#' @param reference_table the reference table
#'
#' @return a tibble with unique episodes and patients reported by ICU
#' @export
#'
#' @examples
#' unit_admissions(events, reference)
unit_admissions <- function(events_table = NULL, reference_table = NULL){

  unit_numbers <- events_table %>%
    dplyr::filter(code_name == "NIHR_HIC_ICU_0002") %>%
    dplyr::select(episode_id, string) %>%
    collect() %>%
    dplyr::right_join(reference_table, by = "episode_id") %>%
    dplyr::select(episode_id, nhs_number, string, site) %>%
    dplyr::group_by(site, string) %>%
    dplyr::summarise(patients = n_distinct(nhs_number),
                     episodes = n_distinct(episode_id)) %>%
    dplyr::rename(unit = string)

  return(unit_numbers)

}


#' Calculate Episode Length
#'
#' There are several ways to potentially define the end of an episode.
#' This algorithm performs a stepwise search to define the episode
#' end from:
#' \itemize{
#'   \item episode end date time: 0412
#'   \item date and time of in unit death: 0042 and 0043
#'   \item date and time of brainstem death: 0044 and 0045
#'   \item date and time of body removed: 0038 and 0039
#' }
#'
#' If date and time of death preceed the discharge time (which may
#' in principle only be administrative) we overright the episode
#' end datetime with the death details
#'
#' Validation is coded as follows:
#' \itemize{
#'   \item 0: episode validates as ok
#'   \item 1: there is no episode end datetime
#'   \item 2: episode stay was <= 0 - i.e. not possible
#' }
#'
#' @param core core table from \code{make_core()}
#' @param useDeath logical value to determine if this calculation should include death data
#'
#' @return a tibble with temporal episode figures, length of stay and a validation code
#' @export
#'
#' @examples
#' epi_length(reference, tbls[["events"]])
epi_length <- function(core_table, reference_table = NULL, events_table = NULL) {

  # Find the episode end time from administrative records
  on_unit_exit <- episode_end_generic(reference_table = reference_table,
                               events_table = events_table,
                               code_name = "NIHR_HIC_ICU_0412")

  # Find the end time by death
  on_death <- resolve_date_time(core_tbl = core_table, "NIHR_HIC_ICU_0042", "NIHR_HIC_ICU_0043") %>%
    dplyr::mutate(date_time = lubridate::as_datetime(date_time)) %>%
    dplyr::rename(death_time = date_time)

  # Find the end time by brainstem death
  on_brainstem_death <- resolve_date_time(core_tbl = core_table, "NIHR_HIC_ICU_0044", "NIHR_HIC_ICU_0045") %>%
    dplyr::mutate(date_time = lubridate::as_datetime(date_time)) %>%
    dplyr::rename(brainstem_death_time = date_time)

  # Find the end time by body removal
  on_body_removed <- resolve_date_time(core_tbl = core_table, "NIHR_HIC_ICU_0038", "NIHR_HIC_ICU_0039") %>%
    dplyr::mutate(date_time = lubridate::as_datetime(date_time)) %>%
    dplyr::rename(body_time = date_time)

  # Combine the above with some conditional logic to decide which takes precidence
  combined <- on_unit_exit %>%
    dplyr::left_join(on_death, by = "episode_id") %>%
    dplyr::left_join(on_brainstem_death, by = "episode_id") %>%
    dplyr::left_join(on_body_removed, by = "episode_id") %>%
    dplyr::mutate(
      end_date = if_else(
        is.na(end_date) | ((death_time < end_date) & !is.na(death_time)),
                             death_time, end_date)) %>%
    dplyr::mutate(
      end_date = if_else(
        is.na(end_date) | ((brainstem_death_time < end_date) & !is.na(brainstem_death_time)),
        brainstem_death_time, end_date)) %>%
    dplyr::mutate(
      end_date = if_else(
        is.na(end_date) & is.na(brainstem_death_time) & is.na(death_time) & !is.na(body_time),
        body_time, end_date)) %>%
    dplyr::select(episode_id, site, start_date, end_date) %>%
    dplyr::rename(epi_end_dttm = end_date,
                  epi_start_dttm = start_date) %>%
    dplyr::mutate(los = difftime(epi_end_dttm, epi_start_dttm, units = "days")) %>%
    dplyr::mutate(validity = ifelse(is.na(epi_end_dttm), 1L,
                               ifelse(los <= 0, 2L, 0L)))

  return(combined)

}


#' Indentify Spells
#'
#' some sites have patients check out of one ICU and into another (for example ICU stepdown to HDU).
#' This checks to see if patients are discharged from 1 unit and admitted to another wihtin a pre-defined
#' time period, specified in the minutes argument.
#'
#' This only evaluates episodes that have already been flagged as valid by the episode_length function.
#'
#' @param episode_length episode length tibble
#' @param episodes episodes tibble
#' @param minutes numeric value to define transition period
#'
#' @return a tibble with spells identified and coded
#' @export
#'
#' @examples
#' identify_spells(episode_length, episodes)
identify_spells <- function(episode_length = NULL, episodes = NULL, minutes = 60) {

  episode_length %>%
    filter(validity == 0) %>%
    left_join(episodes %>%
                select(episode_id, nhs_number),
              by = "episode_id") %>%
    arrange(nhs_number, epi_start_dttm) %>%
    group_by(nhs_number) %>%
    # check how much time patient spent outside the unit
    mutate(time_out = epi_start_dttm[-1] %>%
             difftime(epi_end_dttm[-length(epi_end_dttm)], units = "mins") %>%
             as.integer() %>%
             c(NA)) %>%
    mutate(new_spell = if_else(lag(time_out) > minutes | is.na(lag(time_out)), TRUE, FALSE)) %>%
    ungroup() %>%
    mutate(spell_id = cumsum(new_spell)) %>%
    select(spell_id, episode_id, nhs_number, site, epi_start_dttm, epi_end_dttm, los, validity)

}


#' Collect Unit Discharge Status
#'
#' pulls the discharge status
#'
#' @param event_table main event table
#'
#' @return a tibble with unit discharge status
#' @export
#'
#' @examples
#' unit_discharge_status(events)
unit_discharge_status <- function(event_table) {

  event_table %>%
    filter(code_name == "NIHR_HIC_ICU_0097") %>%
    select(string, episode_id) %>%
    collect()

}


#' Collect Episode End Datetime
#'
#' Collects episodes end datetime for further processing
#'
#' @param core_table core table from \code{make_core()}
#'
#' @return a tibble with mandatory episode defining characteristics.
#' @export
#'
#' @importFrom lubridate is.POSIXct ymd_hms
#' @importFrom tidyr spread
#' @importFrom dplyr select filter collect rename mutate_if
#'
#' @examples
#' episode_end_generic(reference, tbl[["events"]])
episode_end_generic <- function(reference_table = NULL, events_table = NULL, code_name = "NIHR_HIC_ICU_0412") {

  sym_code_name <- rlang::sym("code_name")
  quo_column <- enquo(code_name)

  episode_end <- events_table %>%
    dplyr::select(episode_id, !! sym_code_name, datetime) %>%
    dplyr::filter(sym_code_name == quo_column) %>%
    dplyr::collect() %>%
    dplyr::rename(end_date = datetime)

    if (class(episode_end$end_date) == "numeric") {
      episode_end <- episode_end %>%
        dplyr::mutate(end_date = lubridate::as_datetime(end_date))
    }

    episode_boundaries <-
      dplyr::left_join(reference_table, episode_end, by = c("episode_id" = "episode_id")) %>%
      dplyr::select(episode_id, nhs_number, start_date, end_date, site)

    return(episode_boundaries)

}


#' Resolve Datetime of events
#'
#' Many events in CC-HIC are stored in separate date and time columns/objects. This function
#' attempts to reconcile and combine these times when possible. Of note,
#' date and time information is not always stored with consistent rules. For example,
#' death date and time, are stored for every patient in every episode, even though
#' the patient can only die once. The following
#' are some date and time pairings that denote a singular event:
#' \itemize{
#'   \item "NIHR_HIC_ICU_0042", "NIHR_HIC_ICU_0043" - Unit Death
#'   \item "NIHR_HIC_ICU_0038", "NIHR_HIC_ICU_0039" - Body Removal
#'   \item "NIHR_HIC_ICU_0044", "NIHR_HIC_ICU_0045" - Brain stem death
#'   \item "NIHR_HIC_ICU_0048", "NIHR_HIC_ICU_0049" - Treatment Withdrawal
#'   \item "NIHR_HIC_ICU_0050", "NIHR_HIC_ICU_0051" - Discharge ready
#'}
#' If a date or time component is missing, nothing is returned as the datetime
#' cannot be accurately formed.
#'
#' @param core core table from \code{\link{make_core()}}
#' @param date_code the cc-hic code for the date of interest
#' @param time_code the cc-hic code for the time of interest
#'
#' @return a table with the correct datetime pairing for the codes given
#' @export
#'
#' @importFrom rlang .data sym
#'
#' @examples
#' resolve_date_time(code, "NIHR_HIC_ICU_0042", "NIHR_HIC_ICU_0043") # unit death dttm
resolve_date_time <- function(core_tbl = NULL,
                              date_code = as.character(NULL),
                              time_code = as.character(NULL)) {

    stopifnot(any(is.null(c(core_table, date_code, time_code))))

    misaligned <- core_tbl %>%
      dplyr::select(
        .data$episode_id, .data$code_name, .data$date, .data$time) %>%
      dplyr::filter(
        rlang::sym("code_name") %in% c(date_code, time_code)) %>%
      dplyr::collect()

    date_tbl <- misaligned %>%
      dplyr::select(.data$episode_id, .data$date) %>% na.omit()

    time_tbl <- misaligned %>%
      dplyr::select(.data$episode_id, .data$time) %>% na.omit()

    aligned <- dplyr::inner_join(date_tbl, time_tbl, by = "episode_id")

    if (
      attributes(
        class(
          core_tbl$src$con))$package == "RSQLite") {

    aligned <- aligned %>%
      dplyr::mutate(date_time = date + time) %>%
      dplyr::select(episode_id, date_time)

    } else {

    aligned <- aligned %>%
      dplyr::mutate(date_time = lubridate::ymd_hms(
        paste0(
          date, time, sep = " "), tz = "Europe/London")) %>%
      dplyr::select(episode_id, date_time)
    }

  return(aligned)

}



#' Summarise Episode Validation
#'
#' Gives an overview summary of validation codes for the episode table
#'
#' #' validity is coded as:
#' \itemize{
#'   \0 - Validated
#'   \1 - Invalid: no end date to episode length
#'   \2 - Invalid: negative length of stay
#'   \3 = Invalid: length of stay under 6 hours
#' }
#'
#' @param x
#'
#' @return a tibble containing summary information for validation at episode level
#' @export
#'
#' @examples
#' episode_validity(episode_length)
episode_validity <- function(x) {

  x %<>%
    group_by(site, validity) %>%
    summarise(episodes = n()) %>%
    spread(key = validity, value = episodes)

}





#' #' Calculate Estimated Site Occupancy
#' #'
#' #' @param episode_length_tbl episode length table
#' #' @param episodes_tbl episodes table
#' #' @param provenance_tbl provenance table
#' #'
#' #' @return a table of similar structure to date_skelaton, but with estimated occupancies attached
#' #' @export
#' #'
#' #' @examples
#' calc_site_occupancy <- function(episode_length_tbl = NULL, impute = TRUE) {
#'
#'   all_sites <- c("Oxford", "RYJ", "GSTT", "UCL", "RGT")
#'
#'   date_skelaton <- make_date_skelaton()
#'
#'   occupancy_vec <- c()
#'
#'   for (i in 1:nrow(date_skelaton)) {
#'
#'     insert_this <- episode_length_tbl %>%
#'       dplyr::filter(site == date_skelaton$site[i],
#'                     date_skelaton$date[i] >= epi_start_dttm & date_skelaton$date[i] <= epi_end_dttm) %>%
#'       nrow()
#'
#'     occupancy_vec <- c(occupancy_vec, insert_this)
#'
#'   }
#'
#'   date_skelaton$est_occupancy <- occupancy_vec
#'
#'   occupancy <- date_skelaton
#'
#'   if (!impute) {
#'     return(occupancy)
#'   } else {
#'     occupancy$est_occupancy <- ifelse(occupancy$est_occupancy == 0 & occupancy$site == "RGT", 38,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "UCL", 24,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "Oxford", 11,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "RYJ", 23,
#'                              occupancy$est_occupancy))))
#'
#'     return(occupancy)
#'
#'   }
#'
#'
#' }


