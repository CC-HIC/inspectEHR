#' Report Weekly Admissions
#'
#' Shows the number of admissions to each each in terms of patients and episodes
#' stratified in weeks
#'
#' @param distinct_episodes from reference table
#' @return a summary containing patient and episode numbers
#' @export
#'
#' @importFrom dplyr group_by summarise n_distinct
#' @importFrom magrittr %>%
#' @importFrom lubridate day month year
#'
#' @examples
#' weekly_admissions(distinct_episodes)
weekly_admissions <- function(distinct_episodes = NULL) {
  admissions <- distinct_episodes %>%
    dplyr::mutate(
      year = lubridate::year(start_date),
      month = lubridate::month(start_date, label = TRUE),
      week_of_month = as.integer(ceiling(lubridate::day(start_date) / 7))
    ) %>%
    dplyr::group_by(site, year, month, week_of_month) %>%
    dplyr::summarise(
      patients = dplyr::n_distinct(nhs_number),
      episodes = dplyr::n_distinct(episode_id)
    )
}


#' Reports Case Numbers according to day
#'
#' @param unique_cases_tbl from \code{pull_cases_all}
#'
#' @return breakdown of unique daily cases
#' @export
#'
#' @importFrom dplyr group_by summarise n_distinct
#' @importFrom magrittr %>%
#' @importFrom lubridate day month year wday
#'
#' @examples
#' report_cases_daily(unique_cases)
report_cases_daily <- function(unique_cases_tbl = NULL) {
  cases <- unique_cases_tbl %>%
    mutate(
      year = lubridate::year(start_date),
      month = lubridate::month(start_date, label = TRUE),
      week_of_month = as.integer(ceiling(lubridate::day(start_date) / 7)),
      wday = lubridate::wday(start_date, label = TRUE)
    ) %>%
    dplyr::group_by(site, year, month, week_of_month, wday) %>%
    dplyr::summarise(
      patients = dplyr::n_distinct(nhs_number),
      episodes = dplyr::n_distinct(episode_id)
    )
}


#' Daily Admissions for each Site
#'
#' Calculates the number of admissions for each calendar day, stratified
#' by site. This is a complete table, i.e. days with 0 admissions are not
#' listed
#'
#' @param reference the reference table generated by \code{\link{make_reference}}
#' @param by_site the named site of interest as a character
#'
#' @return a tibble with the number of unique episodes admitted for a given day
#' @export
#'
#' @importFrom dplyr filter mutate group_by summarise n_distinct
#' @importFrom lubridate date
#'
#' @examples
#' daily_admssions(unique_cases, by_site == "UCL")
daily_admssions <- function(reference = NULL, by_site = NULL) {
  admissions <- reference %>%
    dplyr::filter(site == by_site) %>%
    dplyr::mutate(date = lubridate::date(start_date)) %>%
    dplyr::group_by(date) %>%
    dplyr::summarise(episodes = dplyr::n_distinct(episode_id)) %>%
    dplyr::filter(episodes > 0)
}


#' Event Occurrances for each Site
#'
#' Calculates the number of event occurances for each calendar day, stratified
#' by site. Days with 0 event submissions are not listed
#'
#' @param extracted_event extracted HIC event
#' @param by_site a site code as a character vector
#'
#' @return a tibble with the number of unique episodes admitted for a given day
#' @export
#'
#' @examples
#' event_occurrances(x, by_site == "UCL")
event_occurrances <- function(extracted_event = NULL, by_site = "UCL") {
  occurances <- extracted_event %>%
    filter(site == by_site) %>%
    mutate(date = lubridate::date(datetime)) %>%
    group_by(date) %>%
    summarise(events = n_distinct(internal_id)) %>%
    filter(events > 0)

  return(occurances)
}


#' Report Admission Numbers for each Unit
#'
#' Reports on ICNARC CMP unit codes to describe the numbers of reported cases by
#' site. This is dependent on accurate parsing of the xml schema for hic code
#' 0002 (INCARC CMP unit code). And as such, may dramatically under-report. To
#' see a comprehensive list of acual cases, see the
#' \code{\link{weekly_admissions}} function.
#'
#' @param events_table the events table
#' @param reference_table the reference table
#'
#' @return a tibble with unique episodes and patients reported by ICU
#' @export
#'
#' @examples
#' unit_admissions(events, reference)
unit_admissions <- function(events_table = NULL, reference_table = NULL) {
  unit_numbers <- events_table %>%
    dplyr::filter(code_name == "NIHR_HIC_ICU_0002") %>%
    dplyr::select(episode_id, string) %>%
    collect() %>%
    dplyr::right_join(reference_table, by = "episode_id") %>%
    dplyr::select(episode_id, nhs_number, string, site) %>%
    dplyr::group_by(site, string) %>%
    dplyr::summarise(
      patients = n_distinct(nhs_number),
      episodes = n_distinct(episode_id)
    ) %>%
    dplyr::rename(unit = string)

  return(unit_numbers)
}


#' Characterise Episodes
#'
#' There are several ways to potentially define an episode. Fundamentally, we
#' need a start and an end datetime. The start is already required to onboard
#' patients into the database and so is 100% complete. This function primary
#' serves to identify the end of an epsiode, which is often much less clearly
#' defined. Potential sources of information, in order of precidence include:
#' \itemize{
#'   \item date and time of in unit death: 0042 and 0043
#'   \item date and time of brainstem death: 0044 and 0045
#'   \item episode end date time: 0412
#'   \item date and time of body removed: 0038 and 0039
#'   \item the last regularly recorded observation from HR (0108) and SpO2
#'     (0129)
#' }
#' The goal is not to create a perfect record, as doing so drops too many cases.
#' Rather, the goal is to characterise the episode in a meaningful way. This
#' means that episodes cannot have negative episode length, and you should not
#' be able to record a vital sign after a death has occurred. If date and time
#' of death preceed the discharge time we overwrite the episode end datetime
#' with the date and time of death. The same is not true for brainstem death and
#' body removal. This would result in a situation whereby a body is kept
#' physiologically active on the ICU, but the episode is now listed as finished.
#'
#' Since a patient can only die once, checks are also performed to ensure that
#' death events, can only be linked to a single episode. This is relevent for
#' the following situations:
#' \itemize{
#'   \item More than one episode has become linked with the same death event. In
#'     this situation, the final episode is closed with an end datetime of the
#'     datetime of death. The death is then uncoupled from any prior episodes
#'   \item A patient was discharged alive, but subseqnetly died.
#' }
#' Checks are taken to ensure that episodes are non-overlapping, though they can
#' run immediately from one to the next.
#'
#' @param connection a connection to the CC-HIC database
#'
#' @return a tibble that characterises each episode. The attribute "invalid_records"
#'   contains information related to invalid records and the reason for invalidation
#' @export
#'
#' @importFrom rlang abort
#'
#' @examples
#' epi_length(ctn)
characterise_episodes <- function(connection = NULL) {

  if (is.null(connection)) {
    rlang::abort("connection must be supplied")
  }

  df_extract <- tribble(
    ~codes, ~names,
    "NIHR_HIC_ICU_0411", "epi_start_dttm",
    "NIHR_HIC_ICU_0412", "src_end_dttm",
    "NIHR_HIC_ICU_0042", "death_date",
    "NIHR_HIC_ICU_0043", "death_time",
    "NIHR_HIC_ICU_0044", "bsd_date",
    "NIHR_HIC_ICU_0045", "bsd_time",
    "NIHR_HIC_ICU_0038", "body_date",
    "NIHR_HIC_ICU_0039", "body_time",
    "NIHR_HIC_ICU_0073", "nhs",
    "NIHR_HIC_ICU_0097", "outcome",
    "NIHR_HIC_ICU_0400", "bsd"
  )
  

  # df <- extract_demographics(
  #   tbl(ctn, "events"),
  #   collect(tbl(ctn, "variables")),
  #   df_extract$codes,
  #   df_extract$names
  # )

  df <- extract_demographics(
    connection = connection,
    code_names = df_extract$codes,
    rename = df_extract$names)

  df <- df %>%
    mutate(
      death_dttm = if_else(!is.na(death_date) & !is.na(body_time),
                           paste0(format(death_date), " ", format(body_time)), as.character(NA))) %>%
    mutate(death_dttm = if_else(!is.na(death_dttm), lubridate::ymd_hms(death_dttm), as.POSIXct(NA))) %>%
    mutate(
      bsd_dttm = if_else(!is.na(bsd_date) & !is.na(bsd_time),
                           paste0(format(bsd_date), " ", format(bsd_time)), as.character(NA))) %>%
    mutate(bsd_dttm = if_else(!is.na(bsd_dttm), lubridate::ymd_hms(bsd_dttm), as.POSIXct(NA))) %>%
    mutate(
      body_dttm = if_else(!is.na(body_date) & !is.na(body_time),
                           paste0(format(body_date), " ", format(body_time)), as.character(NA))) %>%
    mutate(body_dttm = if_else(!is.na(body_dttm), lubridate::ymd_hms(body_dttm), as.POSIXct(NA)))

  df <- df %>%
    select(-tidyselect::ends_with("date"), -tidyselect::ends_with("time")) %>%
    mutate(nhs_validation = if_else(
      validate_nhs(nhs), 1L, 0L
    ))

  invalid_records <- df %>% filter(nhs_validation == 0) %>%
    select(episode_id) %>%
    mutate(reason = "invalid nhs number")

  df <- df %>%
    filter(nhs_validation == 1) %>%
    filter(nhs != "0000000000") %>%
    select(-nhs_validation)

  invalid_records <- df %>%
    filter(outcome == "E") %>%
    select(episode_id) %>%
    mutate(reason = "open episode") %>%
    bind_rows(invalid_records)

  df <- df %>% filter(outcome != "E")

  ## Discharged alive and no src end date is invalid
  ## Disacharge alive, with an end date, automatically VALID

  df <- df %>%
    dplyr::mutate(
      epi_end_dttm = dplyr::case_when(
        outcome == "A" & is.na(src_end_dttm) ~ as.POSIXct(NA),
        outcome == "A" & !is.na(src_end_dttm) ~ src_end_dttm,
        outcome == "D" & !is.na(death_dttm) & bsd == 0 | is.na(bsd) ~ death_dttm,
        outcome == "D" & bsd == 1 & !is.na(death_dttm) ~ bsd_dttm,
        TRUE ~ as.POSIXct(NA)
      )
    )

  broken_timings <- df %>%
    filter(is.na(epi_end_dttm) | epi_end_dttm < epi_start_dttm) %>%
    select(-epi_end_dttm)

  recover_timings <- tbl(connection, "events") %>%
    filter(episode_id %in% broken_timings$episode_id,
           code_name %in% c("NIHR_HIC_ICU_0108", "NIHR_HIC_ICU_0129")) %>%
    select(episode_id, datetime) %>%
    collect() %>%
    group_by(episode_id) %>%
    summarise(epi_end_dttm = max(datetime)) %>%
    filter(!is.na(epi_end_dttm)) %>%
    left_join(broken_timings, ., by = "episode_id")

  df <- df %>%
    filter(!(episode_id %in% broken_timings$episode_id)) %>%
    bind_rows(recover_timings)

  invalid_records <- df %>%
    filter(is.na(epi_end_dttm)) %>%
    select(episode_id) %>%
    mutate(reason = "no end datetime") %>%
    bind_rows(invalid_records)

  invalid_records <- df %>%
    filter(!is.na(epi_end_dttm)) %>%
    filter(epi_end_dttm < epi_start_dttm) %>%
    select(episode_id) %>%
    mutate(reason = "end time prior to admission") %>%
    bind_rows(invalid_records)

  df <- df %>%
    filter(!is.na(epi_end_dttm)) %>%
    filter(epi_end_dttm >= epi_start_dttm)

  duplicate_start <- df %>%
    ungroup() %>%
    distinct(nhs, epi_start_dttm, .keep_all = TRUE) %>%
    select(episode_id) %>%
    anti_join(df, by = "episode_id") %>%
    select(episode_id) %>%
    mutate(reason = "duplicate start datetime")

  duplicate_end <- df %>%
    ungroup() %>%
    distinct(nhs, epi_start_dttm, .keep_all = TRUE) %>%
    select(episode_id) %>%
    anti_join(df, by = "episode_id") %>%
    select(episode_id) %>%
    mutate(reason = "duplicate end datetime")

  overlapping <- df %>%
    group_by(nhs) %>%
    arrange(nhs, epi_start_dttm) %>%
    mutate(time_out = difftime(epi_start_dttm, lag(epi_end_dttm))) %>%
    ungroup() %>%
    filter(time_out < 0) %>%
    select(episode_id) %>%
    mutate(reason = "overlapping episode")
  
  invalid_records <- bind_rows(
    invalid_records,
    duplicate_start,
    duplicate_end,
    overlapping
  )

  df <- df %>%
    select(episode_id, nhs, epi_start_dttm, epi_end_dttm, outcome) %>%
    rename(nhs_number = nhs) %>%
    anti_join(invalid_records, by = "episode_id")
    arrange(nhs, epi_start_dttm)
  
  attr(df, "invalid_records") <- invalid_records
  
  return(df)
}


#' Indentify Spells
#'
#' some sites have patients check out of one ICU and into another (for example ICU stepdown to HDU).
#' This checks to see if patients are discharged from 1 unit and admitted to another wihtin a pre-defined
#' time period, specified in the minutes argument.
#'
#' This only evaluates episodes that have already been flagged as valid by the episode_length function.
#'
#' @param episode_length episode length tibble
#' @param episodes episodes tibble
#' @param minutes numeric value to define transition period
#'
#' @return a tibble with spells identified and coded
#' @export
#'
#' @examples
#' identify_spells(episode_length, episodes)
identify_spells <- function(episode_length = NULL, episodes = NULL, minutes = 60) {
  episode_length %>%
    filter(validity == 0) %>%
    left_join(episodes %>%
      select(episode_id, nhs_number),
    by = "episode_id"
    ) %>%
    arrange(nhs_number, epi_start_dttm) %>%
    group_by(nhs_number) %>%
    # check how much time patient spent outside the unit
    mutate(time_out = epi_start_dttm[-1] %>%
      difftime(epi_end_dttm[-length(epi_end_dttm)], units = "mins") %>%
      as.integer() %>%
      c(NA)) %>%
    mutate(new_spell = if_else(lag(time_out) > minutes | is.na(lag(time_out)), TRUE, FALSE)) %>%
    ungroup() %>%
    mutate(spell_id = cumsum(new_spell)) %>%
    select(spell_id, episode_id, nhs_number, site, epi_start_dttm, epi_end_dttm, los, validity)
}


#' Collect Unit Discharge Status
#'
#' pulls the discharge status
#'
#' @param event_table main event table
#'
#' @return a tibble with unit discharge status
#' @export
#'
#' @examples
#' unit_discharge_status(events)
unit_discharge_status <- function(event_table) {
  event_table %>%
    filter(code_name == "NIHR_HIC_ICU_0097") %>%
    select(string, episode_id) %>%
    collect()
}


#' Collect Episode End Datetime
#'
#' Collects episodes end datetime for further processing
#'
#' @param core_table core table from \code{make_core()}
#'
#' @return a tibble with mandatory episode defining characteristics.
#' @export
#'
#' @importFrom lubridate is.POSIXct ymd_hms
#' @importFrom tidyr spread
#' @importFrom dplyr select filter collect rename mutate_if
#'
#' @examples
#' episode_end_generic(reference, tbl[["events"]])
episode_end_generic <- function(reference_table = NULL, events_table = NULL, code_name = "NIHR_HIC_ICU_0412") {
  sym_code_name <- rlang::sym("code_name")
  quo_column <- enquo(code_name)

  episode_end <- events_table %>%
    dplyr::select(episode_id, !!sym_code_name, datetime) %>%
    dplyr::filter(sym_code_name == quo_column) %>%
    dplyr::collect() %>%
    dplyr::rename(end_date = datetime)

  if (class(episode_end$end_date) == "numeric") {
    episode_end <- episode_end %>%
      dplyr::mutate(end_date = lubridate::as_datetime(end_date))
  }

  episode_boundaries <-
    dplyr::left_join(reference_table, episode_end, by = c("episode_id" = "episode_id")) %>%
    dplyr::select(episode_id, nhs_number, start_date, end_date, site)

  return(episode_boundaries)
}


#' Resolve Datetime of events
#'
#' Many events in CC-HIC are stored in separate date and time columns/objects. This function
#' attempts to reconcile and combine these times when possible. Of note,
#' date and time information is not always stored with consistent rules. For example,
#' death date and time, are stored for every patient in every episode, even though
#' the patient can only die once. The following
#' are some date and time pairings that denote a singular event:
#' \itemize{
#'   \item "NIHR_HIC_ICU_0042", "NIHR_HIC_ICU_0043" - Unit Death
#'   \item "NIHR_HIC_ICU_0038", "NIHR_HIC_ICU_0039" - Body Removal
#'   \item "NIHR_HIC_ICU_0044", "NIHR_HIC_ICU_0045" - Brain stem death
#'   \item "NIHR_HIC_ICU_0048", "NIHR_HIC_ICU_0049" - Treatment Withdrawal
#'   \item "NIHR_HIC_ICU_0050", "NIHR_HIC_ICU_0051" - Discharge ready
#' }
#' If a date or time component is missing, nothing is returned as the datetime
#' cannot be accurately formed.
#'
#' @param core core table from \code{\link{make_core()}}
#' @param date_code the cc-hic code for the date of interest
#' @param time_code the cc-hic code for the time of interest
#'
#' @return a table with the correct datetime pairing for the codes given
#' @export
#'
#' @importFrom rlang .data sym
#'
#' @examples
#' resolve_date_time(code, "NIHR_HIC_ICU_0042", "NIHR_HIC_ICU_0043") # unit death dttm
resolve_date_time <- function(core_tbl = NULL,
                              date_code = as.character(NULL),
                              time_code = as.character(NULL)) {
  stopifnot(any(is.null(c(core_table, date_code, time_code))))

  misaligned <- core_tbl %>%
    dplyr::select(
      .data$episode_id, .data$code_name, .data$date, .data$time
    ) %>%
    dplyr::filter(
      rlang::sym("code_name") %in% c(date_code, time_code)
    ) %>%
    dplyr::collect()

  date_tbl <- misaligned %>%
    dplyr::select(.data$episode_id, .data$date) %>%
    na.omit()

  time_tbl <- misaligned %>%
    dplyr::select(.data$episode_id, .data$time) %>%
    na.omit()

  aligned <- dplyr::inner_join(date_tbl, time_tbl, by = "episode_id")

  if (
    attributes(
      class(
        core_tbl$src$con
      )
    )$package == "RSQLite") {
    aligned <- aligned %>%
      dplyr::mutate(date_time = date + time) %>%
      dplyr::select(episode_id, date_time)
  } else {
    aligned <- aligned %>%
      dplyr::mutate(date_time = lubridate::ymd_hms(
        paste0(
          date, time,
          sep = " "
        ),
        tz = "Europe/London"
      )) %>%
      dplyr::select(episode_id, date_time)
  }

  return(aligned)
}



#' Summarise Episode Validation
#'
#' Gives an overview summary of validation codes for the episode table
#'
#' #' validity is coded as:
#' \itemize{
#'   \0 - Validated
#'   \1 - Invalid: no end date to episode length
#'   \2 - Invalid: negative length of stay
#'   \3 = Invalid: length of stay under 6 hours
#' }
#'
#' @param x
#'
#' @return a tibble containing summary information for validation at episode level
#' @export
#'
#' @examples
#' episode_validity(episode_length)
episode_validity <- function(x) {
  x %<>%
    group_by(site, validity) %>%
    summarise(episodes = n()) %>%
    spread(key = validity, value = episodes)
}





#' #' Calculate Estimated Site Occupancy
#' #'
#' #' @param episode_length_tbl episode length table
#' #' @param episodes_tbl episodes table
#' #' @param provenance_tbl provenance table
#' #'
#' #' @return a table of similar structure to date_skelaton, but with estimated occupancies attached
#' #' @export
#' #'
#' #' @examples
#' calc_site_occupancy <- function(episode_length_tbl = NULL, impute = TRUE) {
#'
#'   all_sites <- c("Oxford", "RYJ", "GSTT", "UCL", "RGT")
#'
#'   date_skelaton <- make_date_skelaton()
#'
#'   occupancy_vec <- c()
#'
#'   for (i in 1:nrow(date_skelaton)) {
#'
#'     insert_this <- episode_length_tbl %>%
#'       dplyr::filter(site == date_skelaton$site[i],
#'                     date_skelaton$date[i] >= epi_start_dttm & date_skelaton$date[i] <= epi_end_dttm) %>%
#'       nrow()
#'
#'     occupancy_vec <- c(occupancy_vec, insert_this)
#'
#'   }
#'
#'   date_skelaton$est_occupancy <- occupancy_vec
#'
#'   occupancy <- date_skelaton
#'
#'   if (!impute) {
#'     return(occupancy)
#'   } else {
#'     occupancy$est_occupancy <- ifelse(occupancy$est_occupancy == 0 & occupancy$site == "RGT", 38,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "UCL", 24,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "Oxford", 11,
#'                              ifelse(occupancy$est_occupancy == 0 & occupancy$site == "RYJ", 23,
#'                              occupancy$est_occupancy))))
#'
#'     return(occupancy)
#'
#'   }
#'
#'
#' }
