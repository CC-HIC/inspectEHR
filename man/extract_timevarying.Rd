% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_timevarying.R
\name{extract_timevarying}
\alias{extract_timevarying}
\title{Extract & Reshape Timevarying Dateitems}
\usage{
extract_timevarying(connection, episode_ids = NULL, code_names,
  rename = NULL, chunk_size = 5000, cadance = 1,
  overlap_method = "distinct")
}
\arguments{
\item{connection}{a CC-HIC database connection}

\item{episode_ids}{an integer vector of episode_ids or NULL. If NULL (the
default) then all episodes are extracted}

\item{code_names}{a vector of CC-HIC codes names to be extracted}

\item{rename}{a character vector of names you want to relabel CC-HIC codes
as, or NULL (the default) if you do not want to relabel.}

\item{chunk_size}{a chunking parameter to help speed up the function and
manage memory constaints}

\item{cadance}{a numerical scalar or one of "exact" or "timestamp". If a
numerical scalar is used, it will describe the base time unit to build each
row, in divisions of an hour. For example: 1 = 1 hour, 0.5 = 30 mins, 2 = 2
hourly. If multiple events occur within the specified time, then the first
is chosen and the others are dropped. If cadance = "exact", then the EXACT
datetime will be used at the time column. This is likely to generate a
LARGE table, so use cautiously.}

\item{overlap_method}{a summary function to adress the issue of extracting
data that is contributed at a higher resolution than your cadance. The
default behaviour is "distinct" which simply disgards any excess data.}
}
\value{
sparse tibble with hourly cadance as rows, and unique hic events as
  columns
}
\description{
This is the workhorse function that transcribes 2d data from CC-HIC to a
table with 1 column per dataitem (and any metadata if relevent) and 1 row per
time per patient.
}
\details{
The time unit is user definable, and set by the "cadance" argument. The
default behaviour is to produce a table with 1 row per hour per patient.

Many events inside CC-HIC occur on a greater than hourly basis. Depending
upon the chosen analysis, you may which to increase the cadance. 0.5 for
example will produce a table with 1 row per 30 minutes per patient.

Where you are extacting at a resolution lower than is recorded in the
database, you can specify a summary function with the \code{overlap_method}
argument. This argument takes a summary function as an argument, for example,
mean and will apply this behaviour to all data items in the database. At
present, this doesn't deal with: functions that act differently across
different data types, or metadata.

Choose what variables you want to pull out wisely. This function is actually
quite efficient considering what it needs to do, but it can take a very long
time if pulling out lots of data. It is a strong recomendation that you
optimise the database with indexes prior to using this function.

It is perfectly possible for this function to produce negative time rows. If,
for example a patient had a measure taken in the hours before they were
admitted, then this would be added to the table with a negative time value.
As a concrete example, if a patient had a sodium measured at 08:00, and they
were admitted to the ICU at 20:00 the same day, then the sodium would be
displayed at time = -12. This is normal behaviour it is left to the end user
to determine how best they wish to account for this.
}
\examples{
# DB Connection
db_pth <- system.file("testdata/synthetic_db.sqlite3", package = "inspectEHR")
ctn <- connect(sqlite_file = db_pth)

# Extract Heart Rates for 5 episodes with default settings
hr_default <- extract_timevarying(ctn, episode_ids = 13639:13643, code_names = "NIHR_HIC_ICU_0108")
head(hr_default)
# Extract Heart Rates for 5 episodes with custom settings
hr_custom <- extract_timevarying(ctn, episode_ids = 13639:13643, code_names = "NIHR_HIC_ICU_0108", cadance = 2, overlap_method = mean)
head(hr_custom)
DBI::dbDisconnect(ctn)
}
